#!/usr/bin/env python2
# Tool to assign unique CAN bus data identifiers to devices
#
# Copyright (C) 2021  Kevin O'Connor <kevin@koconnor.net>
#
# This file may be distributed under the terms of the GNU GPLv3 license.
import sys, os, optparse, time, logging, random, ConfigParser as configparser
import can

CFG_HEADER = """# Config file for CANBUS id mappings

# This file is automatically generated.  DO NOT MODIFY THIS FILE!
# See Klipper canbus_assigner.py for details.

"""

class CANDevices:
    def __init__(self, cfgfile):
        self.cfgfile = cfgfile
        self.id_to_uuid = {}
        self.uuid_to_id = {}
        idmap = self._read_config()
        self._set_idmap(idmap)
    def fatal(self, msg=None):
        if msg is not None:
            logging.error(msg)
        sys.exit(-1)
    def _set_idmap(self, idmap):
        self.id_to_uuid = idmap
        self.uuid_to_id = {uuid: cid for cid, uuid in idmap.items()}
        if len(self.id_to_uuid) != len(self.uuid_to_id):
            self.fatal("Duplicate uuid in idmap!")
    def _read_config(self):
        mfile = configparser.ConfigParser()
        try:
            mfile.read(self.cfgfile)
        except configparser.error as e:
            logging.exception("Error on read config file read")
            self.fatal()
        if not mfile.has_section('canbus_nodes'):
            return {}
        idmap = {}
        for name, val in mfile.items('canbus_nodes'):
            cid = uuid = -1
            if name.startswith('node'):
                try:
                    cid = int(name[4:])
                    uuid = int(val, 16)
                except ValueError:
                    pass
            if cid < 0 or cid > 255 or uuid < 0 or uuid > 0xffffffffffff:
                self.fatal("Invalid config node %s=%s" % (name, val))
            idmap[cid] = uuid
        return idmap
    def set_cid(self, uuid, cid):
        # Build new_idmap
        prev_uuid = self.id_to_uuid.get(cid)
        if prev_uuid is not None:
            if uuid == prev_uuid:
                # Mapping already present
                return
            self.fatal("Can't reuse id %d (%012x vs %012x)"
                       % (cid, uuid, prev_uuid))
        new_idmap = dict(self.id_to_uuid)
        new_idmap[cid] = uuid
        # Build new config
        mfile = configparser.ConfigParser()
        mfile.add_section('canbus_nodes')
        for cid, uuid in sorted(new_idmap.items()):
            mfile.set('canbus_nodes', 'node%03d' % (cid,), '%012x' % (uuid,))
        # Verify existing config file hasn't changed
        check_idmap = self._read_config()
        if check_idmap != self.id_to_uuid:
            self.fatal("Config file externally modified!")
        # Write updated config file
        try:
            f = open(self.cfgfile, "w")
            f.write(CFG_HEADER)
            mfile.write(f)
            f.flush()
            os.fsync(f.fileno())
            f.close()
        except:
            logging.exception("Unable to write config file")
            self.fatal()
        self._set_idmap(new_idmap)
    def get_cid(self, uuid):
        cid = self.uuid_to_id.get(uuid)
        if cid is not None:
            return cid
        # Allocate new id
        avail_cid = [i for i in range(256) if i not in self.id_to_uuid]
        if not avail_cid:
            logging.error("No available ids for new uuid %012x", uuid)
            return None
        new_cid = random.choice(avail_cid)
        self.set_cid(uuid, new_cid)
        return new_cid

CANBUS_ID_ADMIN = 0x3f0
CMD_QUERY_UNASSIGNED = 0
CMD_SET_CANID = 2
RESP_NEED_CANID = 32
RESP_HAVE_CANID = 33

class CANAdminHandler:
    def __init__(self, canbus_iface, devmap):
        self.canbus_iface = canbus_iface
        self.devmap = devmap
        self.bus = None
    def open_bus(self):
        filters = [{"can_id": CANBUS_ID_ADMIN + 1, "can_mask": 0x7ff,
                    "extended": False}]
        try:
            bus = can.interface.Bus(channel=self.canbus_iface,
                                    can_filters=filters, bustype='socketcan')
        except can.CanError:
            logging.exception("Error opening CAN bus")
            time.sleep(30.)
            return
        self.bus = bus
    def close_bus(self):
        if self.bus is not None:
            self.bus.shutdown()
            self.bus = None
        time.sleep(5.)
    def send_msg(self, data):
        if self.bus is None:
            return
        msg = can.Message(arbitration_id=CANBUS_ID_ADMIN,
                          data=data, is_extended_id=False)
        try:
            self.bus.send(msg)
        except can.CanError:
            logging.exception("Error on CAN message send")
            self.close_bus()
    def handle_msg(self, curtime, msg):
        if msg.arbitration_id != CANBUS_ID_ADMIN + 1 or msg.dlc != 8:
            return
        cid = msg.data[7]
        uuid = sum([v << ((5-i)*8) for i, v in enumerate(msg.data[1:7])])
        if msg.data[0] == RESP_HAVE_CANID:
            self.devmap.set_cid(uuid, cid)
        elif msg.data[0] == RESP_NEED_CANID:
            cid = self.devmap.get_cid(uuid)
            if cid is not None:
                self.send_msg([CMD_SET_CANID] + list(msg.data[1:7]) + [cid])
    def run(self):
        next_query_time = 0.
        while 1:
            if self.bus is None:
                self.open_bus()
                continue
            try:
                msg = self.bus.recv(1.)
            except can.CanError:
                logging.exception("Error on CAN message receive")
                self.close_bus()
                continue
            curtime = time.time()
            if msg is not None:
                self.handle_msg(curtime, msg)
            if curtime >= next_query_time:
                next_query_time = curtime + 5.
                self.send_msg([CMD_QUERY_UNASSIGNED])

def main():
    usage = "%prog [options] <config file> <can interface>"
    opts = optparse.OptionParser(usage)
    options, args = opts.parse_args()
    if len(args) != 2:
        opts.error("Incorrect number of arguments")
    cfgfile, canbus_iface = args

    devmap = CANDevices(cfgfile)
    msg_handler = CANAdminHandler(canbus_iface, devmap)
    msg_handler.run()

if __name__ == '__main__':
    main()
